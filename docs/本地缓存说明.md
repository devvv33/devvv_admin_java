# 本地缓存 (LocalCache) 说明文档

## 概述

本地缓存模块提供了一种在 JVM 内存中维护数据缓存的机制，并通过 Redis 发布订阅实现多实例间的缓存同步。

**核心特性：**
- 数据存储在 JVM 内存中，读取速度极快
- 支持多实例部署时的缓存一致性（通过 Redis Pub/Sub）
- 懒加载机制，按需初始化

## 相关代码所在目录
[core/config/cache/local](../module-commons/commons-core/src/main/java/com/devvv/commons/core/config/cache/local)

## 架构设计

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           应用实例 A                                      │
│  ┌──────────────────┐    ┌──────────────────┐    ┌──────────────────┐   │
│  │  SettingManager  │    │ AdminUserManager │    │   MenuManager    │   │
│  │   (LocalCache)   │    │   (LocalCache)   │    │  (LocalCache)    │   │
│  └────────┬─────────┘    └────────┬─────────┘    └────────┬─────────┘   │
│           │                       │                       │             │
│           └───────────────────────┼───────────────────────┘             │
│                                   │                                     │
│                        ┌──────────▼──────────┐                          │
│                        │  LocalCacheFactory  │                          │
│                        │    (实例管理工厂)    │                          │
│                        └──────────┬──────────┘                          │
│                                   │                                     │
│           ┌───────────────────────┼───────────────────────┐             │
│           │                       │                       │             │
│  ┌────────▼─────────┐   ┌────────▼─────────┐   ┌────────▼─────────┐    │
│  │LocalCachePublisher│   │LocalCacheListener│   │   LocalCache    │    │
│  │    (发布通知)     │   │   (接收通知)      │   │    (接口)       │    │
│  └────────┬─────────┘   └────────▲─────────┘   └──────────────────┘    │
└───────────┼──────────────────────┼──────────────────────────────────────┘
            │                      │
            │   Redis Pub/Sub      │
            ▼                      │
┌───────────────────────────────────────────────────────────────────────┐
│                              Redis                                     │
│                                                                       │
│   Channel: SettingManager    Channel: AdminUserManager    ...         │
└───────────────────────────────────────────────────────────────────────┘
            │                      ▲
            │                      │
┌───────────┼──────────────────────┼──────────────────────────────────────┐
│           ▼                      │            应用实例 B                 │
│  ┌──────────────────┐   ┌────────┴─────────┐                           │
│  │LocalCachePublisher│   │LocalCacheListener│                           │
│  └──────────────────┘   └──────────────────┘                           │
│                                   │                                     │
│                        ┌──────────▼──────────┐                          │
│                        │  LocalCacheFactory  │                          │
│                        └──────────┬──────────┘                          │
│                                   │                                     │
│  ┌──────────────────┐    ┌───────▼──────────┐    ┌──────────────────┐   │
│  │  SettingManager  │    │ AdminUserManager │    │   MenuManager    │   │
│  │   (LocalCache)   │    │   (LocalCache)   │    │  (LocalCache)    │   │
│  └──────────────────┘    └──────────────────┘    └──────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
```

## 核心组件

### 1. LocalCache (接口)

定义本地缓存的基本行为规范。

```java
public interface LocalCache {
    // 发送更新通知（静态方法）
    static void notifyReload(LocalCacheEnums cacheEnum, String... keys);
    
    // 缓存初始化
    void init();
    
    // 根据 key 重新加载缓存
    void reload(List<String> keys);
}
```

### 2. LocalCacheEnums (枚举)

注册所有本地缓存实现类，每个枚举值对应一个缓存实现。

```java
public enum LocalCacheEnums {
    SettingManager("系统配置", "com.devvv.commons.manager.sys.manager.SettingManager"),
    AdminUserManager("后台用户", "com.devvv.cms.manager.AdminUserManager"),
    MenuManager("菜单管理", "com.devvv.cms.manager.MenuManager"),
    ;
    
    private final String desc;       // 描述
    private final String className;  // 实现类全限定名
}
```

### 3. LocalCacheFactory (工厂类)

管理缓存实例的创建和获取，采用单例模式 + 懒加载。

```java
// 获取缓存实例
// create = true: 不存在时创建
// create = false: 不存在时返回 null
LocalCache cache = LocalCacheFactory.getInstance(LocalCacheEnums.SettingManager, true);
```

**特性：**
- 使用 `ConcurrentHashMap` 保证线程安全
- 优先从 Spring 容器获取 Bean，获取不到则反射实例化
- 实例化时自动调用 `init()` 方法

### 4. LocalCachePublisher (发布者)

通过 Redis 发布订阅发送缓存更新通知。

```java
// 发布更新通知
LocalCachePublisher.notifyReload(LocalCacheEnums.SettingManager, "key1", "key2");
```

### 5. LocalCacheListener (监听者)

监听 Redis 消息，收到通知后触发对应缓存的 `reload()` 方法。

### 6. LocalCacheAutoConfiguration (自动配置)

Spring Boot 自动配置类，负责：
- 注册 Redis 消息监听容器
- 为所有 `LocalCacheEnums` 创建对应的 Topic 监听

## 工作流程

### 初始化流程

```
1. 应用启动
       ↓
2. Spring 容器初始化 Bean（如 SettingManager）
       ↓
3. @PostConstruct 调用 getInstance()
       ↓
4. LocalCacheFactory.getInstance() 创建实例
       ↓
5. 调用 init() 方法加载数据到内存
```

### 更新同步流程

```
1. 业务代码修改数据（如修改配置）
       ↓
2. 事务提交后调用 LocalCache.notifyReload()
       ↓
3. LocalCachePublisher 向 Redis 发布消息
       ↓
4. 所有实例的 LocalCacheListener 收到消息
       ↓
5. 调用对应缓存的 reload() 方法刷新内存数据
```

## 使用示例

### 示例：SettingManager (系统配置管理)

`SettingManager` 以 key-value 的方式在内存中维护全局配置，在配置发生变更时能广播通知到所有实例。

**这是 Nacos 的轻量级替代方案**：如果是单体项目或不依赖 Nacos 时，使用 `SettingManager` 也能够在程序运行时动态刷新配置。


#### 使用方式

```java
// 方式一：通过静态方法获取实例
String value = SettingManager.getInstance().getString("my.config.key");

// 方式二：通过 Spring 注入
@Resource
private SettingManager settingManager;

String value = settingManager.getString("my.config.key");
```

## 如何创建新的本地缓存

### Step 1: 在 LocalCacheEnums 中注册

```java
public enum LocalCacheEnums {
    // 已有的...
    SettingManager("系统配置", "com.devvv.commons.manager.sys.manager.SettingManager"),
    
    // 新增
    MyNewCache("我的缓存", "com.example.MyNewCacheManager"),
    ;
}
```

### Step 2: 创建实现类

```java
@Slf4j
@Component
public class MyNewCacheManager implements LocalCache {

    // 内存中的缓存数据
    private Map<String, MyData> dataMap = new ConcurrentHashMap<>();

    @Override
    public void init() {
        // 从数据库或其他数据源加载数据
        dataMap = loadFromDatabase();
        log.info("MyNewCache 初始化完成，数据量: {}", dataMap.size());
    }

    @Override
    public void reload(List<String> keys) {
        if (keys == null || keys.isEmpty()) {
            // 全量刷新
            init();
        } else {
            // 增量刷新（可选优化）
            for (String key : keys) {
                MyData data = loadSingleFromDatabase(key);
                if (data != null) {
                    dataMap.put(key, data);
                } else {
                    dataMap.remove(key);
                }
            }
        }
    }

    @PostConstruct
    public void postConstruct() {
        getInstance();
    }

    public static MyNewCacheManager getInstance() {
        return LocalCacheFactory.getInstance(LocalCacheEnums.MyNewCache, true);
    }

    // 业务方法
    public MyData getByKey(String key) {
        return dataMap.get(key);
    }
}
```

### Step 3: 在数据变更时发送通知

```java
// 在数据修改后发送通知
public void updateData(String key, MyData data) {
    // 保存到数据库
    saveToDatabase(key, data);
    
    // 发送广播通知（建议在事务提交后执行）
    BusiTransactionUtil.execAfterCommit(() -> 
        LocalCache.notifyReload(LocalCacheEnums.MyNewCache, key)
    );
}
```

## 注意事项

### 1. 内存占用
本地缓存将数据存储在 JVM 内存中，需要注意：
- 评估数据量大小，避免 OOM
- 对于大数据量，考虑只缓存热点数据

### 2. 数据一致性
- 更新通知是**最终一致性**，存在短暂的数据不一致窗口期
- 如果 Redis 消息丢失，可能导致缓存不一致
- 建议在关键业务中使用 `reload()` 强制刷新

### 3. Redis 依赖
- 多实例部署时必须配置 Redis（`sysJedisConnectionFactory`）
- 单实例部署时，即使没有 Redis 也能正常工作（只是无法跨实例同步）

### 4. 启动顺序
- 确保 Spring 容器完全初始化后再访问缓存
- 使用 `@PostConstruct` 进行初始化时机较为合适

### 5. 线程安全
- `LocalCacheFactory` 使用 `ConcurrentHashMap`，获取实例是线程安全的
- 缓存实现类内部的数据结构需要自行保证线程安全

