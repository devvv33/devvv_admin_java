# 分布式锁模块说明文档

## 概述

本模块基于 Redisson 实现了一套支持微服务场景的分布式锁方案。核心特点是**支持同一请求链路下跨服务重入**，即在微服务调用链中，上下游服务可以对同一资源重复加锁而不会产生死锁。

## 模块结构

```
lock/
├── MyGlobalRequestRedissonLock.java  # 自定义 Redisson 锁实现（核心）
├── BusiRedissonLockUtil.java         # 业务层分布式锁工具类
└── LockTransactionResource.java      # 锁与事务协同资源
```

## 核心设计

### 1. 请求链级别的可重入锁

传统的 Redisson 可重入锁基于 `threadId` 实现重入，但在微服务场景下，一个客户端请求可能穿越多个服务，每个服务的线程 ID 都不同，导致无法实现跨服务重入。

**本模块的解决方案**：将锁的重入标识从 `threadId` 改为 `globalRequestId`（请求链 ID），实现同一请求链路下的跨服务重入。

```java
// 原 RedissonLock 实现
long threadId = Thread.currentThread().getId();

// 本模块实现
long threadId = BusiContextHolder.getOrSetGlobalRequestId();
```

### 2. 锁与事务自动协同

锁的释放时机与事务状态绑定，无需手动管理锁的生命周期：

- 事务提交 → 自动释放锁
- 事务回滚 → 自动释放锁

---

## 使用场景

### 场景一：用户资金操作

```java
@Transactional
public void recharge(Long userId, BigDecimal amount) {
    // 锁定用户  lockUserId()必须在事务环境中调用
    BusiRedissonLockUtil.lockUserId(userId);
    
    // 增加余额
    accountService.add(userId, amount);
    
    // 事务提交后自动释放锁
}
```

### 场景二：订单状态变更

```java
@Transactional
public void confirmOrder(String orderId) {
    // 锁定订单  lockObject()必须在事务环境中调用
    BusiRedissonLockUtil.lockObject("order:" + orderId);
    
    Order order = orderDao.selectById(orderId);
    if (order.getStatus() != OrderStatus.PENDING) {
        throw new BusiException("订单状态不正确");
    }
    
    order.setStatus(OrderStatus.CONFIRMED);
    orderDao.updateById(order);
    
    // 事务提交后自动释放锁
}
```

### 场景三：定时任务防重

```java
@Scheduled(cron = "0 0 2 * * ?")
public void dailyReport() {
    BusiRedissonLockUtil.tryLockExec("task:daily-report", () -> {
        // 生成日报
        reportService.generateDailyReport();
    }).ifLockedThrow("日报生成任务正在执行中");
}
```

### 场景四：微服务调用链加锁

```
客户端请求 (globalRequestId=123456)
    │
    ▼
┌─────────────────────────────────────────────────────┐
│  服务 A                                              │
│  BusiRedissonLockUtil.lockUserId(1001)              │
│  // 首次加锁成功，重入次数: 1                         │
│                                                      │
│  ┌─────────────────────────────────────────────┐    │
│  │  服务 B (RPC 调用)                           │    │
│  │  BusiRedissonLockUtil.lockUserId(1001)      │    │
│  │  // 同一 globalRequestId，重入成功，次数: 2  │    │
│  └─────────────────────────────────────────────┘    │
│                                                      │
│  // 服务 B 返回后，重入次数减为 1                     │
└─────────────────────────────────────────────────────┘
    │
    ▼
请求结束，锁完全释放
```

---

## 注意事项

1. **必须在事务环境中使用 `lockUserId` 和 `lockObject`**
   - 这两个方法依赖事务管理器来自动释放锁
   - 非事务环境下调用会抛出异常

2. **同一事务中同类型锁只能加一次**
   - 不能在同一事务中多次调用 `lockUserId` 或多次调用 `lockObject`
   - 如需锁定多个资源，请分多个事务处理

3. **锁的等待时间为 30 秒**
   - `lockUserId` 和 `lockObject` 的等待时间固定为 30 秒
   - 超时未获取到锁会抛出 `BusiException`

4. **请求链 ID 的传递**
   - 确保在微服务调用时正确传递 `globalRequestId`
   - 这是跨服务重入的关键

5. **简单任务锁不支持重入**
   - `tryLockExec` 使用的是普通 Redisson 锁，不支持跨服务重入

---

## 依赖关系

```
BusiRedissonLockUtil
    ├── SysRedisson                       # Redis 客户端
    │   └── MyGlobalRequestRedissonLock   # 自定义锁实现
    ├── BusiTransactionResourceManager    # 事务资源管理器
    └── LockTransactionResource           # 锁事务资源
        └── RLock                         # Redisson 锁接口
```


---

## 类详解

### 1. MyGlobalRequestRedissonLock

**作用**：自定义的 Redisson 锁实现，拷贝自 `RedissonLock` 并进行改造。

**核心改动**：
- 所有涉及 `threadId` 的地方改为使用 `BusiContextHolder.getOrSetGlobalRequestId()`
- 支持同一请求链路下的跨服务重入

**涉及的方法**：
| 方法 | 说明 |
|------|------|
| `lock()` | 阻塞式加锁 |
| `tryLock()` | 尝试加锁（非阻塞） |
| `tryLock(waitTime, unit)` | 带超时的尝试加锁 |
| `tryLock(waitTime, leaseTime, unit)` | 带超时和持有时间的尝试加锁 |
| `unlock()` | 释放锁 |
| `isHeldByCurrentThread()` | 判断当前请求链是否持有锁 |

### 2. BusiRedissonLockUtil

**作用**：业务层使用的分布式锁工具类，提供静态方法供业务代码调用。

#### 2.1 用户锁 `lockUserId(Long userId)`

对指定用户 ID 加锁，适用于需要对用户资源进行互斥操作的场景。

**使用限制**：
1. 必须在事务环境中调用
2. 同一事务中不能重复调用
3. 无需手动释放，事务结束后自动释放

**锁 Key 格式**：`lock:userId:{userId}`

```java
@Transactional
public void transferMoney(Long userId, BigDecimal amount) {
    // 对用户加锁
    BusiRedissonLockUtil.lockUserId(userId);
    
    // 业务逻辑...
    
    // 无需手动释放锁，事务结束后自动释放
}
```

#### 2.2 对象锁 `lockObject(String key)`

对指定 Key 加锁，适用于需要对任意资源进行互斥操作的场景。

**使用限制**：
1. 必须在事务环境中调用
2. 同一事务中不能重复调用
3. 无需手动释放，事务结束后自动释放

**锁 Key 格式**：`lock:obj:{key}`

```java
@Transactional
public void updateOrder(String orderId) {
    // 对订单加锁
    BusiRedissonLockUtil.lockObject("order:" + orderId);
    
    // 业务逻辑...
    
    // 无需手动释放锁，事务结束后自动释放
}
```

#### 2.3 简单任务锁 `tryLockExec(String lockKey, ThrowingSupplier/ThrowingRunnable)`

不依赖事务的简单加锁执行，方法执行完毕即释放锁。

**特点**：
- 不依赖事务环境
- 加锁失败不会抛异常，返回 `TryLockResult` 供业务判断
- 方法执行完毕立即释放锁

```java
// 带返回值
TryLockResult<String> result = BusiRedissonLockUtil.tryLockExec("task:sync", () -> {
    // 执行任务
    return "success";
});
String value = result.ifLockedThrow("任务正在执行中");

// 无返回值
TryLockResult<?> result = BusiRedissonLockUtil.tryLockExec("task:clean", () -> {
    // 执行清理任务
});
result.ifLockedThrow();
```

### 3. LockTransactionResource

**作用**：将分布式锁作为事务资源进行管理，实现锁与事务的生命周期绑定。

**执行顺序**：`order() = 999`，确保锁在事务其他行为（如数据库操作）都执行完毕后再释放。

**生命周期**：
| 阶段 | 行为 |
|------|------|
| begin | 无操作（锁已在绑定时获取） |
| commit | 释放锁 |
| rollback | 释放锁 |

### 4. TryLockResult

**作用**：`tryLockExec` 方法的返回结果包装类，提供优雅的加锁失败处理方式。

**主要方法**：
| 方法 | 说明 |
|------|------|
| `isLocked()` | 判断是否因为锁被占用而加锁失败 |
| `ifLockedThrow()` | 加锁失败时抛出默认异常 |
| `ifLockedThrow(String msg)` | 加锁失败时抛出自定义消息异常 |
| `ifLockedThrow(RuntimeException e)` | 加锁失败时抛出指定异常 |
| `ifLockedThrow(Function)` | 加锁失败时使用函数生成异常 |

